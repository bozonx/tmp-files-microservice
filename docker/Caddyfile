
{  
  admin localhost:2019  
}

:80 {
    # Public: allow unauthenticated file downloads for tmp-files
    @public_tmp_files_download {
        method GET
        path_regexp public_download ^/tmp-files/api/v1/download/[^/]+$
    }
    handle @public_tmp_files_download {
        uri strip_prefix /tmp-files

        reverse_proxy tmp-files-microservice:80 {
            header_up X-Forwarded-Proto {http.request.scheme}
            header_up X-Forwarded-For {http.request.remote.host}
            header_up X-Real-IP {http.request.remote.host}

            health_uri /api/v1/health
            health_interval 30s
        }
    }

    # Shared Bearer auth: single token from {env.AUTH_TOKENS}
    @authed <<CEL
        header_regexp('auth', 'Authorization', '^\\s*Bearer\\s+(.+?)\\s*$') &&
        ((',' + {env.AUTH_TOKENS} + ',').contains(',' + {re.auth.1} + ','))
    CEL

    # Outer handle: only if authenticated
    handle @authed {
    
        handle /tmp-files* {
            uri strip_prefix /tmp-files

            reverse_proxy tmp-files-microservice:80 {
                header_up X-Forwarded-Proto {http.request.scheme}
                header_up X-Forwarded-For {http.request.remote.host}
                header_up X-Real-IP {http.request.remote.host}

                health_uri /api/v1/health
                health_interval 30s
            }
        }
        
        # Fallback: authenticated but invalid path
        handle {
            respond "Forbidden: Invalid endpoint" 403 {
                close
            }
        }
    }

    # Global fallback: not authenticated
    handle {
        respond "Unauthorized" 401 {
            close
        }
    }
}





